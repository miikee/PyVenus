# pyVenus

## Introduction

pyVenus is developed as an interface between the Hamilton Venus software and python. If you don't have a Hamilton liquid handler and are not familiar with Venus this might not be for you :) 

**The following assumes that you have a basic understanding of Venus and using submethod libraries.**

Both python and Venus have their strength and weaknesses and pyVenus is trying to create synergy between them. The basic idea is that you can exploit the strength of Venus when it comes to anything relating to controlling your liquid handler:

- Setup a decklayout and define sequences
- Define liquid classes
- Setup pipetting steps 

While anything else, like your method logic, data handling, etc. can be done in python, which is much more suited to this. 

## Basic concepts

1. The first step is to define one or more submethod libraries in Venus. This could be simple (or more complex) pipetting functions, but also simple wrappers for any functionality in Venus. 
2. pyVenus parses these libraries and generates corresponding python classes.
3. These classes allow you to call the Venus submethods as if they were native python code. 

## Basic example

Assume you have the following simple submethod in a library that transfers buffer to a target:
![](/pyVenus/images/submethod_example1.png)

The submethod has a few input and output parameters as shown here:
![](/pyVenus/images/submethod_example2.png)

pyVenus generates a python class from the submethod library that has a function of the same name as the submethod:
![](/pyVenus/images/smt_class_example1.png)

The different data types of Venus are implemented through corresponding python classes (more on that later).

As you can see pyVenus is build to work well with IDEs like Visual Studio Code or PyCharm, giving you all the relevant information through IntelliSense. 

## Example method

Let's have a step-by-step look at the example method (```example_method.py```) that comes with pyVenus.

First we import the required functionality from pyVenus as well as the pandas library (used for an example at the end)

```python
from pyVenus import Connection,Variable,Sequence,Device,Helpers
import pandas as pd
```

Next all the python classes generated by pyVenus are imported. To update these resources run ``update_resources.py``.

```python
from venus_resources import Example_layout as lay
from venus_resources import LiquidClasses as lc
from venus_resources import Ml_star
from venus_resources import Channels1ml_8
from venus_resources import Pipetting
```

- **Example_layout** is a representation of the Venus deck layout (```example_layout.lay```) and gives easy access to deck sequence and labware item names. 
- **LiquidClasses** gives access to the liquid class names extracted from the database.
- **Ml_star**, **Channels1ml_8**, and **Pipetting** are submethod library examples that ship with pyVenus.

A crucial step is initiation of the **Connection** object, which will start the Hamilton Run Control, which then awaits further commands.

```python
con = Connection()
```

Next the device object for the Microlab STAR is initiated. This will define the deck layout file to use by the method. As you can see there is now need to write out the name of the deck layout file to use, we can simply pull that information from the layout class imported before. 

Furthermore, each python class representing a submethod library is initiated. 

```python
star_device = Device(con, lay.layout_file)

smt_star = Ml_star(con)
smt_ch = Channels1ml_8(con)
smt_pip = Pipetting(con)
```

Sequences are a critical component of any Venus method. Existing deck sequences can be initiated in python in the following way. It is of course also possible to build sequences dynamically within python. This is discussed further down.

```python
tips_1000F = Sequence(con, lay.Sequences.MlStar1000ulHighVolumeTipWithFilter, deck_sequence=True)
tips_50F = Sequence(con, lay.Sequences.MlStar50ulTipWithFilter, deck_sequence=True)
buffer = Sequence(con, lay.Sequences.trough1, deck_sequence=True)
plate_input = Sequence(con, lay.Sequences.plate_input, deck_sequence=True)
plate_dilution = Sequence(con, lay.Sequences.plate_dilution, deck_sequence=True)
plate_output = Sequence(con, lay.Sequences.plate_output, deck_sequence=True)
waste_ch = Sequence(con, lay.Sequences.Waste, deck_sequence=True)
```

It is important to understand that pyVenus itself does not implement any of the functions present in Venus. Instead functions from Venus are made available by creating submethod libraries, which can then be called in python using pyVenus. 

PyVenus ships with a few example libraries that examplify the usage. One is the ```ml_star.smt``` submethod library, which currently only contains one submethod (```initialize```), which is a simple wrapper for the Initialize command for the STAR. In the future we might add additional functions related to the STAR (e.g. enabling aspiration monitoring (MAD))

![](/pyVenus/images/smt_class_example2.png)

Now that all the neccessary classes are present we can call the initialize command. This will pass the command to the Run Control and make the robot go through this initialization routine. 

```python
smt_star.initialize(star_device)
```




To generate a corresponding python class all you have to do is call one function.

```python
from pyVenus import Resources
Resources.read_submethods()
```

By default this will convert all submethod libraries found at ```./smt/```. But you can specify a path through an optional parameter. 

This will generate a new python file that you can import into your main method.

```python
from venus_resources import Pipetting
```
## Current status

## Installation
    python -m venv .venv
    ".venv/Scripts/activate.bat"
    pip install -r requirements.txt

## How does it work