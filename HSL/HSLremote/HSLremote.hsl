// include standard libraries needed for HSLremote
#include "HSLExtensions\\File.hsl" 
#include "HSLStrLib.hsl"
#include "HSLJson\\HSLJson.hsl"

// define internal variables for HSLremote
namespace HSLremote 
{
   variable strLayout;
   variable strToSystem;
   variable strFromSystem;
   variable intCommandCounter(1);
   variable strFilename;
   file hdlFile;
   timer hdlTimer;
}

variable ___SHUTDOWN___(0);
variable ___ARRAY___[];
//variable ___RETURN___("");
object   ___JSON___;

// function to wait for next command file
//function waitForFile(strFilename)
//{
//   timer hdlTimer;

//   while (HSLExtensions::File::Exists(strFilename) == 0)
 //  {  
  //    hdlTimer.SetTimer(1);
  //    hdlTimer.WaitTimer(hslFalse, hslFalse);
  // }
  // Trace("New command file found (", strFilename, ") >> Executing...");
//}

// function definition for parser
#ifndef HSL_RUNTIME
   function mainLoop(layout);
#endif

// function definition during execution
// this code must be encapsulated inside a function to allow for defining the ML_STAR object on-thy-fly
// ############### OBSOLETE #####################
//#ifdef HSL_RUNTIME
//   function mainLoop(layout)
 //  {
//      // load deck layout
//      //device ML_STAR(layout, "ML_STAR", hslTrue); 
//      
//      // define accessible variables
//      //variable ___SHUTDOWN___(0);
//      //variable ___RETURN___("");
//      //variable ___ARRAY___[];
//      //sequence ___SEQUENCE___;
//        
//      // start main method loop and continue until shut down flag is set
//      while (___SHUTDOWN___ == 0)
//      {
//         // generate filename for next command file
//         HSLremote::strFilename = HSLremote::strToSystem + IStr(HSLremote::intCommandCounter) + ".hsl";
//         
//         // wait for next command file to appear
//         while (HSLExtensions::File::Exists(HSLremote::strFilename) == 0)
//         {  
//            HSLremote::hdlTimer.SetTimer(1);
//            HSLremote::hdlTimer.WaitTimer(hslFalse, hslFalse);
//         }
//        Trace("New command file found (", HSLremote::strFilename, ") >> Executing...");
//         
//         // import command file
//         << HSLremote::strFilename;
//         
//         // reset step return variable
//         //___RETURN___ = "";
//
//         // execute new HSL code
//         __EvalExpr__();
//
//         // increment the command counter         
//         HSLremote::intCommandCounter = HSLremote::intCommandCounter + 1;
//
//         // write step return to file (if needed)
//         if(___RETURN___ != "") {
//            Trace(___RETURN___);
//            HSLremote::hdlFile.AddField(1, ___RETURN___, hslString);
//            HSLremote::hdlFile.SetDelimiter(hslAsciiText);
//            HSLremote::hdlFile.Open(HSLremote::strFromSystem + IStr(HSLremote::intCommandCounter) + ".txt", hslWrite);
//            HSLremote::hdlFile.WriteRecord();
//            HSLremote::hdlFile.Close();
//            HSLremote::hdlFile.RemoveFields();
//         }
//      }
//   }
//#endif
// ############### /// OBSOLETE #####################


function addJSON_variable(object & objJson, variable var, variable strName) void 
{
   if(GetType(var) == "i")
      HSLJsonLib::SetIntegerProperty(objJson, strName, var);
   if(GetType(var) == "f")
      HSLJsonLib::SetFloatProperty(objJson, strName, var);
   if(GetType(var) == "s")
      HSLJsonLib::SetStringProperty(objJson, strName, var);   
}

function addJSON_array(object & objJson, variable arr[], variable strName) void {
   variable intSize, intIndex, item;
   intSize = arr.GetSize();
   HSLJsonLib::SetArray(objJson, strName);
   HSLJsonLib::SetArrayLength(objJson, strName, intSize);
   for(intIndex = 0; intIndex < intSize;)
   {
      item = arr.ElementAt(intIndex);

      if(GetType(item) == "i")
         HSLJsonLib::SetIntegerArrayElement(objJson, strName, intIndex+1, item);
      if(GetType(item) == "f")
         HSLJsonLib::SetFloatArrayElement(objJson, strName, intIndex+1, item);
      if(GetType(item) == "s")
         HSLJsonLib::SetStringArrayElement(objJson, strName, intIndex+1, item);
         
      intIndex = intIndex + 1;  
   } 
}

function addJSON_sequence(object & objJson, sequence seq, variable strName) void {
   variable intIndex;
   object objJson_temp;
   HSLJsonLib::Create(objJson_temp);
   
   HSLJsonLib::SetIntegerProperty(objJson_temp, "current", seq.GetCurrentPosition());
   HSLJsonLib::SetIntegerProperty(objJson_temp, "end", seq.GetCount());

   seq.SetCurrentPosition(1);
   seq.SetCount(seq.GetTotal());


   HSLJsonLib::SetArray(objJson_temp, "labware");
   HSLJsonLib::SetArrayLength(objJson_temp, "labware", seq.GetTotal());
   HSLJsonLib::SetArray(objJson_temp, "position");
   HSLJsonLib::SetArrayLength(objJson_temp, "position", seq.GetTotal());

   for(intIndex = 0; intIndex < seq.GetTotal();)
   {
      HSLJsonLib::SetStringArrayElement(objJson_temp, "labware", intIndex+1, seq.GetLabwareId());
      HSLJsonLib::SetStringArrayElement(objJson_temp, "position", intIndex+1, seq.GetPositionId());
      seq.Increment(1);
      intIndex = intIndex + 1;
   }

   HSLJsonLib::SetJsonProperty(objJson, strName, objJson_temp);
   HSLJsonLib::Release(objJson_temp);
}

method main()
{
   HSLJsonLib::SetTraceLevel(0);
   
   // set location of input and output folders
   HSLremote::strToSystem = HSLExtensions::File::GetDirectoryName(GetFileName()) + "\\toSystem\\";
   HSLremote::strFromSystem = HSLExtensions::File::GetDirectoryName(GetFileName()) + "\\fromSystem\\";
   Trace("Directory >> toSystem: " + HSLremote::strToSystem);
   Trace("Directory >> fromSystem: " + HSLremote::strFromSystem);

   // read information on deck layout file
   //HSLremote::hdlFile.AddField(1, HSLremote::strLayout, hslString);
   //HSLremote::hdlFile.SetDelimiter(hslAsciiText);
   //HSLremote::hdlFile.Open(HSLremote::strToSystem + "deck_layout.txt", hslRead);
   //HSLremote::hdlFile.ReadRecord();
   //HSLremote::hdlFile.Close();
   //HSLremote::hdlFile.RemoveFields();

   // start the main method with the specifiec deck layout
   while (___SHUTDOWN___ == 0)
   {
      // generate filename for next command file
      HSLremote::strFilename = HSLremote::strToSystem + IStr(HSLremote::intCommandCounter) + ".hsl";
      
      // wait for next command file to appear
      while (HSLExtensions::File::Exists(HSLremote::strFilename) == 0)
      {  
         HSLremote::hdlTimer.SetTimer(1);
         HSLremote::hdlTimer.WaitTimer(hslFalse, hslFalse);
      }
      Trace("New command file found (", HSLremote::strFilename, ") >> Executing...");
      
      // import command file
      << HSLremote::strFilename;
      
      // reset step return variable
      //___RETURN___ = "";
      
      // setup JSON object for return information
      HSLJsonLib::Create(___JSON___);

      // execute new HSL code
      #ifdef HSL_RUNTIME
         __EvalExpr__();
      #endif

      // write step return to file
      //Trace(___RETURN___);
      //HSLremote::hdlFile.AddField(1, ___RETURN___, hslString);
      //HSLremote::hdlFile.SetDelimiter(hslAsciiText);
      //HSLremote::hdlFile.Open(HSLremote::strFromSystem + IStr(HSLremote::intCommandCounter) + ".txt", hslWrite);
      //HSLremote::hdlFile.WriteRecord();
      //HSLremote::hdlFile.Close();
      //HSLremote::hdlFile.RemoveFields();

      // reset variables
      //___RETURN___ = "";
      HSLJsonLib::Save(___JSON___, HSLremote::strFromSystem + IStr(HSLremote::intCommandCounter) + ".txt", 1);
      HSLJsonLib::Release(___JSON___);

      // increment the command counter         
      HSLremote::intCommandCounter = HSLremote::intCommandCounter + 1;
   }
   //mainLoop(HSLremote::strLayout);

   // shut down
   return;
}
// $$author=DKBEWO$$valid=0$$time=2021-04-11 22:38$$checksum=6d50c327$$length=083$$